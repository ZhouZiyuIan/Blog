---
title: 强连通分量
date: 2024-12-21 11:46:00
updateDate: 2024-12-21 11:46:00
comments: true
top: 2
---
# 强连通分量


## 一、图的基础定义


+ **连通图**

  在 **无向图** 中，从顶点 $u$ 和 $v$ 有路径，就称顶点 $u$ 和 $v$ 连通。如果图中任意一对顶点都连通，则该图为连通图。


+ **极大连通子图**

  对于 **无向图**$G$ 的某一子连通图，如果它再加上一个点或者边之后它就不连通了，此时该子图就是 **无向图**$G$ 的极大连通子图。

    + 连通图只有一个极大连通子图，就是它本身（唯一）；
    + 非连通图有多个极大连通子图。


+ **连通分量**

  对于 **无向图** 的极大连通子图称为该无向图的连通分量。任何 **连通图** 的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。


+ **强连通图**

  在 **有向图** 中，任意两个顶点 $u$ 和 $v$ 满足 $u$ 到 $v$ 有路径且 $v$ 到 $u$ 也有路径，则称此图为强连通图。


+ **极大强连通子图**

  与极大连通子图概念相似，只是极大连通子图是基于无向图，而极大强连通子图是基于有向图的。


+ **强连通分量**

  与连通分量概念相似，只是连通分量是基于无向图，而强连通分量是基于有向图的。但是需要注意的是，在一个有向图当中可能存在多个强连通分量。 **并且如果当前节点不与任何点强连通，那么当前节点自己就是一个强连通分量 。**


  ![img-1](https://fkzblog.netlify.app/images/img-1.png)


## 二、dfs生成树


$dfs$ 生成树是指在图的深度优先搜索过程中所经历过的图中的顶点和边的组合。通过下图可以简单了解 $dfs$ 生成树的生成过程：


![img-2](https://fkzblog.netlify.app/images/img-2.png)


在生成树中一共有 $4$ 种类型的边 **（不一定全部出现）** ：


1. **树枝边**：上述列子中以 $\textcolor{Green}{\textsf{绿色}}$ 边表示，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。 
2. **反祖边**：上述列子中以 $\textcolor{red}{\textsf{红色}}$ 边表示，也被叫做回边，即指向祖先结点的边。
3. **横叉边**：上述列子中以 $\textcolor{orange}{\textsf{橙色}}$ 边表示，它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点 **不是** 当前结点的祖先。 
4. **前向边**：上述列子中以 $\textcolor{cyan}{\textsf{蓝色}}$ 边表示，它是在搜索的时候遇到子树中的结点的时候形成的。

通过上述概念，我们可以想到 $dfs$ 生成树与强连通分量之间的关系：如果结点 $u$ 是某个强连通分量在 $dfs$ 生成树中遇到的 **第一个结点** ，那么这个强连通分量的其余结点肯定是在搜索树中以 $u$ 为根的子树中。结点 $u$ 也被称为这个强连通分量的根。


## 三、Tarjan算法

$Tarjan$ 算法是基于对图深度优先搜索的算法，用于求解图的连通性问题。一般情况下可以求解有向图的强连通分量、必经点与必经边。同时也可以在线性时间内求出无向图的割点与桥，进一步地可以求解无向图的双连通分量。


### 基本原理

在同一强连通分量上的节点均有路径相连，那么本质上强连通分量上的所有节点都在同一个环上。针对环的处理，多数情况下我们都会强制固定其中一个点作为起点，使整个环结构变成线性结构，俗称 **破环成链** 。而 $Tarjan$ 算法本质也是一样的，选择强连通分量当中某个节点作为强连通分量的根，以此构建一个 $dfs$ 生成树，如下图所示：


![img-3](https://fkzblog.netlify.app/images/img-3.png)


​	


通常情况下对树执行 $dfs$ 相当于把 **同一路径上的节点** 按顺序存储在栈空间里。而以上述方法构建的树中，其叶子节点都 **一定存在一条边连向根节点** 。那么我们就可以借助这 特点，判断如果栈空间上出现了根节点，说明当前路径已构成环，进一步说明当前路径的节点均在同一强连通分量上。不过在解决实际问题的过程中，给定的图不一定是强连通图。比如以下情况：


![img-4](https://fkzblog.netlify.app/images/img-4.png)


由于给定的图不是强连通图，那么当前节点也许是某个强连通分量的根，但是以这个节点构造的生成树下的子节点不一定都在强连通分量当中，如上述例子中的 $3$ 号点。

为了解决这个问题， $Tarjan$ 算法用到了两个非常重要的数组，我们首先需要理解这两个数组各自的含义：


+ $dfn[i]$ 为节点 $i$ 的搜索次序编号（时间戳）。通俗来讲就是节点 $i$ 是在 $dfs$ 生成树中第几个出现的；
+ $low[i]$ 为节点 $i$ 回溯到的最早的栈中结点的 $dfn$ 值。通俗来讲为节点 $i$ 所在的强连通分量的根的 $dfn$ 值。


经过简单思考我们可以得出以下推论：


+ 每个节点的 $dfn$ 值都在第一次被搜到时就确认下来，不会再改变。并且每个节点的 $dfn$ 值均不相同；
+ 如果该图存在强连通分量，那么构建 $dfs$ 生成树时一定存在一个 **最早进入栈空间** 的节点，将此设为强连通分量的根 ，这样能保证根的时间戳在整个强连通分量当中一定最小;
+ 如果该节点不与其它节点强连通，那么该节点的 $dfn$ 和 $low$ 值相等。可以理解为该节点的强连通分量就是其自身，所以他的 $low$ 值等于该强连通分量的根的 $dfn$ 值，也就是等于他自己的 $dfn$ 值。


结合上述推论，将所有节点都执行一遍 $dfs$ ，并将所有节点的 $low$ 值设为 **以当前节点为根的子树下所有子节点中** $dfs$ **值的最小值** 。那么在同一强连通分量上的节点的 $low$ 值将会都是当前强连通分量的根的 $dfn$ 值，从而实现查找强连通分量。


### 算法流程


1. 枚举所有节点作为起点，执行 $dfs$; 


2. 判断当前节点 $now$ 是否存在 $dfn$ 值，若已有 $dfn$ 值则直接返回； 


3. 将 $dfn[now]$ 及 $low[now]$ 设为结点 $now$ 的搜索次序编号（时间戳），并将节点 $now$ 压入栈顶；


4. 接着开始查找所有与节点 $now$ 相连的节点 $next$ ，根据 $dfs$ 生成树的概念，接下来会有四种情况：

   + 如果节点 $now$ 与节点 $next$ 相连的边为 **树枝边** ：

     树枝边指向的为未出现过的节点，所以 $dfn[next]=0$。先将节点 $next$ 执行一遍 $dfs$，更新完节点 $next$ 的 $dfn$ 和 $low$ 值后执行 $low[now]=min(low[now],low[next])$。

      > 针对 $low[now]=min(low[now],low[next])$:
      >
      > + 如果节点 $now$ 不存在于强连通图当中，那么节点 $now$ 在 $dfs$ 生成树上出现的时间一定比节点 $next$ 早，所以 $low$ 值会更低，所以最终结果不会有变化；
      > + 如果节点 $now$ 存在于强连通图当中，那么节点 $now$ 的 $low$ 值一定为强连通分量当中的最小值。那么通过回溯后的 $low$ 值一定是强连通分量的根的 $low$ 值，即最小 $dfn$ 。
   
   + 如果节点 $now$ 与节点 $next$ 相连的边为 **返祖边** ：
   
     返祖边指向的为已出现过的节点，所以 $dfn[next]\neq0$。且由于返祖边指向的节点仍在栈空间内，并且节点 $next$ 的 $low$ 值比当前节点 $now$ 的 $low$ 值更低，说明节点 $next$ 的说明如果继续递归下去将会进入循环，也说明节点 $now$ 在强连通图当中，所以马上更新节点 $now$ 的 $low$ 值。
   
     > 由于路径选择是随机的，所以并不能保证当前路径构成的环包含了强连通分量的根，所以仍然需要通过执行 $low[now]=min(low[now],low[next])$ 来更新 $now$ 节点 的 $low$ 值，以确保回溯到上一个节点时 $low[now]$ 所记录的一定是 **强连通分量** 的根的 $dfn$ 值，而不是某个 **强连通图** 中的根。
   
![img-5](https://fkzblog.netlify.app/images/img-5.png)
   
   + 如果节点 $now$ 与节点 $next$ 相连的边为 **横叉边** ：
   
     横叉边指向的均为已出现的点，所以 $dfn[next]\ne0$。但是由于横叉边指向的点已不在栈空间，说明节点 $next$ 为不属于当前路径上的节点，所以不需要做任何操作。
   
   + 如果节点 $now$ 与节点 $next$ 相连的边为 **前向边** ：
   
   前向边指向的点也已经出现，所以 $dfn[next]\ne0$ 。虽然前向边所指节点 $next$ 还在栈内，但是由于前节点 $next$ 出现的时间一定比节点 $now$ 更晚，所以其 $dfn$ 值一定比节点 $now$ 高，所以即使比较 $low[now]$ 和 $low[next]$ 的值也不会有任何改变，所以也不需要做任何处理。


5. 遍历完节点 $now$ 的所有相邻节点后，将节点 $now$ 弹出栈顶；


6. 选择任意一个 $dfn$ 值为 $0$ 的节点，重复执行 $dfs$  ，直到所有节点均已遍历。

   > 由于整个有向图并不一定是强连通的，随机选择一个节点进行搜索有可能会出现当前节点无法到达的节点，所以需要枚举所有节点直至所有节点的 $dfn$ 值都更新完毕。


### 代码实现


```cpp
void tarjan(int now) {
    //初始化节点 now 的 dfn 和 low 值
	dfn[now] = low[now] = ++time;
    //将节点 now 压入栈中
	stk[++top] = now; vis[now] = 1;
    //找到节点 now 的所有出度并执行
	for (int i = head[now]; i; i = e[i].nxt) {
		int next = e[i].to;
		if (!dfn[next]) {
			tarjan(next);
			low[now] = min(low[now], low[next]);
		} else if (vis[next]) low[now] = min(low[now], dfn[next]);
	}
    //当节点 now 为强连通分量的根,或者不在任何强连通分量当中
    if (low[now] == dfn[now]) {
        //找到一个新的强连通分量(单独一个点也能时一个强连通分量)
        ++cnt;
        //将当前节点前所有还在栈空间内的节点都归为当前强连通分量
        do {
            tmp = stk[top--];
			vis[tmp] = 0;
            //将同一个强连通分量内的点均标记为相同编号
            mar[tmp] = cnt;
		} while(tmp != now);
	}
}
```


## 四、缩点


> 一张有向图，图内每个点都有一个点权。现在需要再图上某点开始移动，在可多次经过同一个点的情况下，求路径上不同的顶点的最大点权和为多少？

最短路问题的求解算法有很多，但是如果在最短路算法的基础上作部分修改，是无法解决上述问题的。因为由于最优解有可能需要多次途径同一个点，则路径上可能存在环，而最短路算法均无法解决有环的情况。

通过简单思考，我们可以知道如果图中存在环，则该环一定存在于该图的强连通分量上。若将图中的强连通分量的所有点都压缩成一个点，那么这个点的点权就是所有点的点权和，入边就是所有点的入边，出边就是所有点的出边。完成缩点后，最后原图便会成为一个有向无环图。当避开了环所造成的影响，那剩下的处理就变得非常简单了。

类似的还有对于一些点权具有传导性的题目时（如依赖、友谊等）也非常适用。


![img-6](https://fkzblog.netlify.app/images/img-6.png)


### 基本思想

在使用 $tarjan$ 算法求强连通分量的过程中使用了一个 $mar$ 数组来记录当前点所属于的强连通分量编号。缩点的基本原理就是通过 **强连通分量编号** 来重新建图，由于所有环一定存在于强连通分量当中，这样能够保证新建的图一定不存在环。


### 算法流程


1. 先执行一遍 $Tarjan$ 算法，让所有节点获取所属强连通分量编号；
2. 遍历每一个节点，判断该点与相邻节点的 **强连通分量编号** 是否相同：
   + 如果编号不同，则两个强连通分量以当前边的信息进行建边。
   + 如果编号不同，则不需要做任何操作。
3. 当所有节点遍历完毕，通过强连通分量编号所建立的图则为缩点后的图。


### 代码实现


```cpp
void solution() {
    //通过tarjan算法将所有强连通分量分配编号
    for (int i = 1; i <= n; i++)
        tarjan(i);
    //遍历所有连边,判断相邻两个节点是否所属同一强连通分量
    for (int i = 1; i <= n; i++) {
        for (int j = head[i]; j; j = e[j].nxt) {
            int tmp = e[j].to;
            //当相邻两个节点不属于同一强连通分量,则以强连通分量编号为点建边
            if (mar[i] != mar[tmp]) {
                link(mar[i], mar[tmp]);
        	}
		}
	}
}
```


>建图本身比较费时，大部分情况下根据题意并不需要建图，通过一定的处理便能解决问题。
